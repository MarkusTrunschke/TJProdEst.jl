<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TJProdEst.jl</title><meta name="title" content="Home · TJProdEst.jl"/><meta property="og:title" content="Home · TJProdEst.jl"/><meta property="twitter:title" content="Home · TJProdEst.jl"/><meta name="description" content="Documentation for TJProdEst.jl."/><meta property="og:description" content="Documentation for TJProdEst.jl."/><meta property="twitter:description" content="Documentation for TJProdEst.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TJProdEst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MarkusTrunschke/TJProdEst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MarkusTrunschke/TJProdEst.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="TJProdEst"><a class="docs-heading-anchor" href="#TJProdEst">TJProdEst</a><a id="TJProdEst-1"></a><a class="docs-heading-anchor-permalink" href="#TJProdEst" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/MarkusTrunschke/TJProdEst.jl">TJProdEst</a>.</p><ul><li><a href="#TJProdEst.Results"><code>TJProdEst.Results</code></a></li><li><a href="#TJProdEst.Setup"><code>TJProdEst.Setup</code></a></li><li><a href="#TJProdEst.bootstrap_tj_prodest-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}"><code>TJProdEst.bootstrap_tj_prodest</code></a></li><li><a href="#TJProdEst.draw_sample-Tuple{}"><code>TJProdEst.draw_sample</code></a></li><li><a href="#TJProdEst.fastOLS-Tuple{}"><code>TJProdEst.fastOLS</code></a></li><li><a href="#TJProdEst.jt_data_prep-Tuple{DataFrame, TJProdEst.Setup}"><code>TJProdEst.jt_data_prep</code></a></li><li><a href="#TJProdEst.lagging_that_panel!-Tuple{}"><code>TJProdEst.lagging_that_panel!</code></a></li><li><a href="#TJProdEst.panel_lag!-Tuple{}"><code>TJProdEst.panel_lag!</code></a></li><li><a href="#TJProdEst.polynomial_fnc_fast!-Tuple{Union{SubArray{&lt;:Number}, Array{&lt;:Number}}, Int64}"><code>TJProdEst.polynomial_fnc_fast!</code></a></li><li><a href="#TJProdEst.polynomial_fnc_fast!-Tuple{Union{SubArray{&lt;:Number}, Array{&lt;:Number}}, Int64}"><code>TJProdEst.polynomial_fnc_fast!</code></a></li><li><a href="#TJProdEst.res_struct_init-Tuple{TJProdEst.Setup}"><code>TJProdEst.res_struct_init</code></a></li><li><a href="#TJProdEst.setup_struct_init-Tuple{Symbol, Symbol, Union{Symbol, Vector{Symbol}}, Symbol, Symbol, Int64, Union{Symbol, Vector{Symbol}}, Union{Missing, Symbol}, Union{Missing, Symbol}, String, Bool, String, Int64, Int64, NamedTuple}"><code>TJProdEst.setup_struct_init</code></a></li><li><a href="#TJProdEst.superscript_this!-Tuple{String}"><code>TJProdEst.superscript_this!</code></a></li><li><a href="#TJProdEst.tj_onestep_estimator-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}"><code>TJProdEst.tj_onestep_estimator</code></a></li><li><a href="#TJProdEst.tj_print_res_bigestimator-Tuple{DataFrame, TJProdEst.Results, TJProdEst.Setup}"><code>TJProdEst.tj_print_res_bigestimator</code></a></li><li><a href="#TJProdEst.tj_prod_est-Tuple{}"><code>TJProdEst.tj_prod_est</code></a></li><li><a href="#TJProdEst.tj_prod_reg!"><code>TJProdEst.tj_prod_reg!</code></a></li><li><a href="#TJProdEst.tj_prod_reg!"><code>TJProdEst.tj_prod_reg!</code></a></li><li><a href="#TJProdEst.tj_prodest_criterion-Tuple{}"><code>TJProdEst.tj_prodest_criterion</code></a></li><li><a href="#TJProdEst.tj_prodest_estimation!-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}"><code>TJProdEst.tj_prodest_estimation!</code></a></li><li><a href="#TJProdEst.tj_std_error_stats-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}"><code>TJProdEst.tj_std_error_stats</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.Results" href="#TJProdEst.Results"><code>TJProdEst.Results</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Results</code></pre><p>Mutable struct storing estimation results with nested NamedTuples for production function and ω law-of-motion parameters.</p><p><strong>Fields</strong></p><ul><li><code>point_estimates::NamedTuple</code>: Point estimates with <code>(prd_fnc, ω_lom)</code> structure</li><li><code>std_errors::NamedTuple</code>: Standard errors </li><li><code>variance::NamedTuple</code>: Variance estimates</li><li><code>p_values::NamedTuple</code>: p-values for hypothesis tests</li><li><code>t_statistics::NamedTuple</code>: t-statistics</li><li><code>conf_intervals::NamedTuple</code>: Confidence intervals (2-element vectors)</li><li><code>criterion_value::Float64</code>: Final GMM criterion value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.Setup" href="#TJProdEst.Setup"><code>TJProdEst.Setup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Setup</code></pre><p>Immutable struct storing estimation configuration and data settings.</p><p><strong>Fields</strong></p><ul><li><code>output::Symbol</code>: Output variable column name</li><li><code>flexible_input::Symbol</code>: Flexible input variable (e.g., materials)</li><li><code>fixed_inputs::Union{Symbol,Vector{Symbol}}</code>: Fixed input(s) (e.g., capital, labor)</li><li><code>flexible_input_price::Symbol</code>: Price for flexible input</li><li><code>all_inputs::Vector{Symbol}</code>: Concatenation of <code>fixed_inputs</code> and <code>flexible_input</code></li><li><code>output_price::Symbol</code>: Output price variable</li><li><code>ω_lom_degree::Int</code>: Polynomial degree for ω law-of-motion</li><li><code>ω_shifter::Union{Symbol, Vector{Symbol}}</code>: Additional shifters in ω LOM</li><li><code>time::Union{Symbol, Missing}</code>: Time variable for panel data</li><li><code>id::Union{Symbol, Missing}</code>: Firm/panel identifier</li><li><code>prd_fnc_form::String</code>: Production function form (e.g., &quot;CobbDouglas&quot;)</li><li><code>std_err_estimation::Bool</code>: Whether to compute standard errors</li><li><code>std_err_type::String</code>: Standard error method (e.g., &quot;Bootstrap&quot;)</li><li><code>boot_reps::Int</code>: Number of bootstrap replications</li><li><code>maximum_boot_tries::Int</code>: Maximum retry attempts for bootstrap</li><li><code>optimizer_options::NamedTuple</code>: Optimization settings (bounds, startvals, optimizer, optim_options)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.bootstrap_tj_prodest-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}" href="#TJProdEst.bootstrap_tj_prodest-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}"><code>TJProdEst.bootstrap_tj_prodest</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bootstrap_tj_prodest(data, Setup, Results) -&gt; Matrix{Float64}</code></pre><p>Generate bootstrap estimates by resampling firms and re-estimating the model. Returns a matrix where each row contains parameter estimates from one bootstrap replication.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Estimation dataset</li><li><code>Setup::Setup</code>: Configuration with <code>boot_reps</code> and <code>maximum_boot_tries</code></li><li><code>Results::Results</code>: Results struct (used for parameter structure)</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Bootstrap estimates matrix of size  <code>(boot_reps × n_params)</code> where n_params = production function params +  ω LOM params. Each row is one bootstrap replication.</li></ul><p><strong>Details</strong></p><ul><li>Uses panel bootstrap: samples firms with replacement, keeps entire time series</li><li>Parallelized across bootstrap repetitions using <code>Threads.@threads</code></li><li>Retries failed estimations up to <code>maximum_boot_tries</code> times per replication</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.draw_sample-Tuple{}" href="#TJProdEst.draw_sample-Tuple{}"><code>TJProdEst.draw_sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">draw_sample(; data, id, sample_size=length(unique(data[!, id])), with_replacement=true) -&gt; DataFrame</code></pre><p>Draw bootstrap sample of firms from panel data. Assigns unique IDs to resampled firms to avoid duplicate ID issues in subsequent panel operations.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>data::DataFrame</code>: Panel dataset to sample from</li><li><code>id::Symbol</code>: Firm identifier column</li><li><code>sample_size::Int</code>: Number of firms to sample (default: all unique firms)</li><li><code>with_replacement::Bool=true</code>: Sample with or without replacement</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.fastOLS-Tuple{}" href="#TJProdEst.fastOLS-Tuple{}"><code>TJProdEst.fastOLS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fastOLS(; Y, X, multicolcheck=true, force=false) -&gt; Vector{Float64}</code></pre><p>Compute OLS coefficients β̂ = (X&#39;X)⁻¹X&#39;Y using in-place Cholesky decomposition for minimal allocations. Optionally checks and handles multicollinearity.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>Y::Union{Matrix, Vector}</code>: Dependent variable(s)</li><li><code>X::Union{Matrix{&lt;:Number}, Vector{&lt;:Number}}</code>: Design matrix of regressors</li><li><code>multicolcheck::Bool=true</code>: Check for perfect multicollinearity</li><li><code>force::Bool=false</code>: Auto-drop multicollinear columns with warning instead of error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.jt_data_prep-Tuple{DataFrame, TJProdEst.Setup}" href="#TJProdEst.jt_data_prep-Tuple{DataFrame, TJProdEst.Setup}"><code>TJProdEst.jt_data_prep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jt_data_prep(data::DataFrame, Setup::Setup) -&gt; DataFrame</code></pre><p>Prepare panel data for estimation by computing proxy variable (log flexible input share) and creating lagged variables. Returns filtered dataset with complete observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.lagging_that_panel!-Tuple{}" href="#TJProdEst.lagging_that_panel!-Tuple{}"><code>TJProdEst.lagging_that_panel!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lagging_that_panel!(; data, id, time, variable, lag_prefix=&quot;lag_&quot;, lags=1, drop_missings=false) -&gt; DataFrame</code></pre><p>Internal helper for <code>panel_lag!</code>. Computes lags using <code>ShiftedArrays.lag</code> within groups, validates time gaps (sets to <code>missing</code> if gap ≠ <code>lags</code>), joins back to data, and renames columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.panel_lag!-Tuple{}" href="#TJProdEst.panel_lag!-Tuple{}"><code>TJProdEst.panel_lag!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">panel_lag!(; data, id, time, variable, lag_prefix=&quot;lag_&quot;, lags=1, drop_missings=false, force=false) -&gt; DataFrame</code></pre><p>Compute panel lags in-place using <code>ShiftedArrays.lag</code> within groups. Sorts by <code>id</code> and <code>time</code>, creates lag columns with specified prefix, and validates time gaps.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>data::DataFrame</code>: Data frame to mutate</li><li><code>id::Symbol</code>: Panel identifier column</li><li><code>time::Symbol</code>: Time variable for ordering</li><li><code>variable::Union{Vector{Symbol},Symbol}</code>: Column(s) to lag</li><li><code>lag_prefix::String=&quot;lag_&quot;</code>: Prefix for lag column names</li><li><code>lags::Int=1</code>: Lag distance</li><li><code>drop_missings::Bool=false</code>: Drop rows with missing lags</li><li><code>force::Bool=false</code>: Remove existing lag columns if present</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.polynomial_fnc_fast!-Tuple{Union{SubArray{&lt;:Number}, Array{&lt;:Number}}, Int64}" href="#TJProdEst.polynomial_fnc_fast!-Tuple{Union{SubArray{&lt;:Number}, Array{&lt;:Number}}, Int64}"><code>TJProdEst.polynomial_fnc_fast!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polynomial_fnc_fast!(poly_mat, degree; par_cal=false) -&gt; poly_mat</code></pre><p>In-place computation of polynomial terms. Fills columns 2 through <code>degree</code> of <code>poly_mat</code> with powers 2 through <code>degree</code> of column 1. Preallocated matrix avoids allocations during repeated calls.</p><p><strong>Arguments</strong></p><ul><li><code>poly_mat::Union{Array{&lt;:Number}, SubArray{&lt;:Number}}</code>: Matrix with base values in column 1</li><li><code>degree::Int</code>: Highest polynomial degree to compute</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>par_cal::Bool=false</code>: Use <code>Threads.@threads</code> for parallel computation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.polynomial_fnc_fast!-Tuple{Union{SubArray{&lt;:Number}, Array{&lt;:Number}}, Int64}" href="#TJProdEst.polynomial_fnc_fast!-Tuple{Union{SubArray{&lt;:Number}, Array{&lt;:Number}}, Int64}"><code>TJProdEst.polynomial_fnc_fast!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polynomial_fnc_fast!(poly_mat, degree; par_cal=false) -&gt; poly_mat</code></pre><p>In-place computation of polynomial terms from a base variable. This function mutates <code>poly_mat</code> by filling its columns with successive powers of the first column: the i-th column is set to (first column)^i.</p><p>This is a performance-optimized version designed for repeated evaluations where the matrix has already been preallocated. It avoids dynamic allocations at runtime by mutating the input matrix directly (hence the trailing <code>!</code>).</p><p><strong>Arguments</strong></p><ul><li><code>poly_mat::Union{Array{&lt;:Number}, SubArray{&lt;:Number}}</code>: A matrix where the first column contains the base values and columns 2 through <code>degree</code> will be filled with polynomial terms. Must have at least <code>degree</code> columns.</li><li><code>degree::Int</code>: The highest polynomial degree to compute. For example, if <code>degree=3</code>, columns 2 and 3 will contain the squared and cubed values of column 1, respectively.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>par_cal::Bool=false</code>: If <code>true</code>, uses parallel computation via <code>Threads.@threads</code> to compute polynomial columns concurrently.</li></ul><p><strong>Returns</strong></p><ul><li>Returns the mutated <code>poly_mat</code> with polynomial columns filled in-place.</li></ul><p><strong>Notes</strong></p><ul><li>The function assumes <code>poly_mat</code> has been preallocated with sufficient columns (at least <code>degree</code> columns). No bounds checking is performed.</li><li>Column 1 is never modified; it serves as the base for all polynomial terms.</li><li>Columns 2 through <code>degree</code> are overwritten with powers 2 through <code>degree</code>.</li><li>For small datasets or low degrees, <code>par_cal=false</code> (sequential) is typically faster due to threading overhead.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Preallocate a matrix with 3 columns for base values and polynomials up to degree 3
poly_mat = zeros(100, 3)
poly_mat[:, 1] .= rand(100)  # Fill first column with base values

# Compute polynomial terms in-place
polynomial_fnc_fast!(poly_mat, 3)
# Now poly_mat[:, 2] contains squared values, poly_mat[:, 3] contains cubed values</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.res_struct_init-Tuple{TJProdEst.Setup}" href="#TJProdEst.res_struct_init-Tuple{TJProdEst.Setup}"><code>TJProdEst.res_struct_init</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">res_struct_init(Setup::Setup) -&gt; Results</code></pre><p>Initialize a <code>Results</code> struct with <code>missing</code> values based on <code>Setup</code> configuration. Creates nested NamedTuples for production function (constant + all_inputs) and ω law-of-motion (ω terms + shifters) parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.setup_struct_init-Tuple{Symbol, Symbol, Union{Symbol, Vector{Symbol}}, Symbol, Symbol, Int64, Union{Symbol, Vector{Symbol}}, Union{Missing, Symbol}, Union{Missing, Symbol}, String, Bool, String, Int64, Int64, NamedTuple}" href="#TJProdEst.setup_struct_init-Tuple{Symbol, Symbol, Union{Symbol, Vector{Symbol}}, Symbol, Symbol, Int64, Union{Symbol, Vector{Symbol}}, Union{Missing, Symbol}, Union{Missing, Symbol}, String, Bool, String, Int64, Int64, NamedTuple}"><code>TJProdEst.setup_struct_init</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setup_struct_init(data, output, flexible_input, fixed_inputs, flexible_input_price,
                  output_price, ω_lom_degree, time, id, prd_fnc_form, options) -&gt; Setup</code></pre><p>Construct a <code>Setup</code> struct with all estimation configuration. Merges user-provided <code>optimizer_options</code>      with defaults and builds <code>all_inputs</code> by concatenating <code>fixed_inputs</code> and <code>flexible_input</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: the input dataset.</li><li><code>output::Symbol</code>: dependent variable (output) column name.</li><li><code>flexible_input::Vector{Symbol}</code>: vector of flexible input column names.</li><li><code>fixed_inputs::Vector{Symbol}</code>: vector of fixed input column names.</li><li><code>flexible_input_price::Symbol</code>: price variable for the flexible input.</li><li><code>output_price::Symbol</code>: price variable for the output.</li><li><code>ω_lom_degree::Int</code>: degree for the ω polynomial (order of LOM terms).</li><li><code>time::Union{Symbol, Missing}</code>: time variable column (or <code>missing</code>).</li><li><code>id::Union{Symbol, Missing}</code>: firm identifier column (or <code>missing</code>).</li><li><code>prd_fnc_form::String</code>: production function form (e.g. &quot;CobbDouglas&quot;).</li><li><code>options::Dict{Symbol,Any}</code>: extra options passed to the estimator.</li></ul><p><strong>Returns</strong></p><ul><li><code>Setup</code>: a filled <code>Setup</code> struct ready to be used by the estimation routine.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.superscript_this!-Tuple{String}" href="#TJProdEst.superscript_this!-Tuple{String}"><code>TJProdEst.superscript_this!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">superscript_this!(c::String) -&gt; Char</code></pre><p>Convert first character of string to its Unicode superscript equivalent using <code>superscript_map</code>. Returns original character if no superscript exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.tj_onestep_estimator-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}" href="#TJProdEst.tj_onestep_estimator-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}"><code>TJProdEst.tj_onestep_estimator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tj_onestep_estimator(data, Setup, Results) -&gt; NamedTuple</code></pre><p>Perform one-step GMM estimation of production function parameters.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Prepared estimation dataset containing output, inputs, prices, and lagged variables. Should be the output of <code>jt_data_prep</code>.</li><li><code>Setup::Setup</code>: Configuration struct containing model specification (variable names, polynomial degree, optimizer settings, etc.).</li><li><code>Results::Results</code>: Results struct that will store the criterion value and is used to determine the structure of output estimates.</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: A nested NamedTuple with two fields:<ul><li><code>prd_fnc</code>: Production function parameters as a NamedTuple with keys like <code>:constant</code>, <code>:K</code>, <code>:L</code>, <code>:M</code> (depends on <code>Setup.all_inputs</code>)</li><li><code>ω_lom</code>: Productivity law-of-motion parameters as a NamedTuple with keys like <code>:ω</code>, <code>:ω²</code>, etc. (depends on <code>Setup.ω_lom_degree</code> and <code>Setup.ω_shifter</code>)</li></ul></li></ul><p><strong>Optimization Details</strong></p><p>The optimization uses <code>Optim.jl</code>&#39;s numerical optimization routines and allows to set all optimizer options with <code>Optim.Options(...)</code>. One can set Box constraints providing the <code>lower_bound</code> and <code>upper_bound</code> arguments in <code>TJProdEst.tj_prod_est</code> combined with a <code>Optim.Fminbox</code> optimizer.</p><p><strong>Throws</strong></p><ul><li>Throws an error with message &quot;Estimation did not converge...&quot; if the optimizer fails to converge.</li><li>Throws an error for unsupported production function forms (currently only &quot;CobbDouglas&quot; is supported).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.tj_print_res_bigestimator-Tuple{DataFrame, TJProdEst.Results, TJProdEst.Setup}" href="#TJProdEst.tj_print_res_bigestimator-Tuple{DataFrame, TJProdEst.Results, TJProdEst.Setup}"><code>TJProdEst.tj_print_res_bigestimator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tj_print_res_bigestimator(data::DataFrame, Results::Results, Setup::Setup)</code></pre><p>Print formatted estimation results table using <code>PrettyTables</code>. Displays production function and ω law-of-motion parameters with standard errors, t-statistics, p-values, and confidence intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.tj_prod_est-Tuple{}" href="#TJProdEst.tj_prod_est-Tuple{}"><code>TJProdEst.tj_prod_est</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tj_prod_est(; data, output, flexible_input, fixed_inputs, flexible_input_price, output_price, ω_lom_degree=1, ω_shifter=[], time, id, std_err_estimation=true, std_err_type=&quot;Bootstrap&quot;, boot_reps=200, maximum_boot_tries=10, optimizer_options=NamedTuple())</code></pre><p>Top-level estimation entry point for production function estimation using the approach described in Trunschke and Judd (2024). Returns a tuple <code>(Results, Setup)</code> with parameter estimates and configuration.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>data::DataFrame</code>: Input dataset with (firm-time) panel structure</li><li><code>output::Symbol</code>: Output variable column name</li><li><code>flexible_input::Symbol</code>: Flexible input variable (e.g., materials)</li><li><code>fixed_inputs::Union{Symbol,Vector{Symbol}}</code>: Fixed input variable(s) (e.g., capital, labor)</li><li><code>flexible_input_price::Symbol</code>: Price of flexible input</li><li><code>output_price::Symbol</code>: Output price</li><li><code>ω_lom_degree::Int=1</code>: Polynomial degree for productivity law-of-motion</li><li><code>ω_shifter::Union{Symbol,Vector{Symbol}}=[]</code>: Optional productivity shifter variables</li><li><code>time::Symbol</code>: Time period identifier</li><li><code>id::Symbol</code>: Firm/unit identifier</li><li><code>std_err_estimation::Bool=true</code>: Whether to compute standard errors</li><li><code>std_err_type::String=&quot;Bootstrap&quot;</code>: Type of standard errors (&quot;Bootstrap&quot; only currently)</li><li><code>boot_reps::Int=200</code>: Number of bootstrap replications</li><li><code>maximum_boot_tries::Int=10</code>: Max retry attempts per failed bootstrap iteration</li><li><code>optimizer_options::NamedTuple=NamedTuple()</code>: Optimization settings (see Optim.jl)</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: <code>(Results, Setup)</code> containing estimates and configuration</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">results = tj_prod_est(
    data = df,
    output = :Y,
    flexible_input = :M,
    fixed_inputs = [:K, :L],
    flexible_input_price = :Pᴹ,
    output_price = :Pʸ,
    time = :year,
    id = :firm_id,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.tj_prod_reg!" href="#TJProdEst.tj_prod_reg!"><code>TJProdEst.tj_prod_reg!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tj_prod_reg!(data, Setup, β, c) -&gt; Nothing</code></pre><p>In-place computation of productivity (ω) terms and the law-of-motion (LOM)  regression for the production function estimation. This function implements  the core calculations for the proxy variable approach, computing current and  lagged productivity, estimating the productivity LOM via OLS, and calculating  the structural error (ξ).</p><p>This is a mutating function (hence the <code>!</code>) that updates the preallocated  arrays in the <code>c</code> cache NamedTuple in-place for efficiency.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: The estimation dataset containing output, inputs, prices,  and lagged variables. Must include columns for current and lagged values of  all production function variables.</li><li><code>Setup::Setup</code>: The setup struct containing configuration parameters including  variable names, polynomial degree, and production function form.</li><li><code>β::Union{Vector{&lt;:Number}, SubArray{...}}</code>: Production function parameters  vector. The ordering is: [constant, fixed<em>input</em>coeffs..., flexible<em>input</em>coeff]. For Cobb-Douglas: β = [α₀, αₖ₁, αₖ₂, ..., αₘ] where K&#39;s are fixed inputs and  M is the flexible input.</li><li><code>c::NamedTuple</code>: Cache NamedTuple containing preallocated arrays for intermediate  calculations. Must include fields: <code>ω_array</code>, <code>ω_lom_array</code>, <code>ρ_hat</code>, <code>ξ_hat</code>.  These arrays are mutated in-place.</li></ul><p><strong>Returns</strong></p><ul><li>Nothing (the function mutates <code>c</code> in-place)</li></ul><p><strong>Side Effects (Mutations)</strong></p><p>The function updates the following fields in <code>c</code>:</p><ul><li><code>c.ω_array</code>: Filled with current productivity (ω) computed from the production  function residual after accounting for inputs and the proxy variable.</li><li><code>c.ω_lom_array</code>: First column filled with lagged productivity (lag<em>ω), then  polynomial terms computed via `polynomial</em>fnc_fast!`, and ω-shifter columns  (if present) that were preallocated during setup.</li><li><code>c.ρ_hat</code>: Filled with OLS coefficients from regressing ω on its lagged  polynomial terms and ω-shifters (the LOM parameters).</li><li><code>c.ξ_hat</code>: Filled with structural error (innovation to productivity), computed  as ξ = ω - LOM(lag<em>ω, ω</em>shifters).</li></ul><p><strong>Implementation Details</strong></p><p>The productivity term ω is recovered from the production function by solving:</p><pre><code class="nohighlight hljs">ω = ln(Y) + ln(Pᴹ·M / Pʸ·Y) - ln(M) - β₀ - βₘ - ∑βₖ·ln(K) - (βₘ - 1)·ln(M)</code></pre><p>where the proxy variable relationship is used to invert for productivity.</p><p>The law-of-motion is estimated via OLS:</p><pre><code class="nohighlight hljs">ω = ρ₀ + ρ₁·lag_ω + ρ₂·lag_ω² + ... + ρₚ·lag_ωᵖ + ρ_shifters·shifters + ξ</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Called internally during GMM criterion evaluation
tj_prod_reg!(est_data, Setup, β_current, cache)
# cache.ξ_hat now contains the structural errors
# cache.ρ_hat contains the LOM parameters</code></pre><p><strong>See Also</strong></p><ul><li><code>tj_prodest_criterion</code>: Uses this function to compute moment conditions</li><li><code>polynomial_fnc_fast!</code>: Computes polynomial terms for the LOM</li><li><code>fastOLS</code>: Estimates the LOM coefficients</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.tj_prod_reg!" href="#TJProdEst.tj_prod_reg!"><code>TJProdEst.tj_prod_reg!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tj_prod_reg!(data, Setup, β, c) -&gt; Nothing</code></pre><p>Compute productivity (ω) and its law-of-motion via in-place OLS regression. Mutates the cache <code>c</code> with productivity terms, LOM parameters, and structural errors.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Estimation dataset with output, inputs, and lagged variables</li><li><code>Setup::Setup</code>: Configuration (variable names, polynomial degree)</li><li><code>β::Vector{&lt;:Number}</code>: Production function parameters [constant, fixed<em>inputs..., flexible</em>input]</li><li><code>c::NamedTuple</code>: Preallocated cache to mutate</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: The function mutates the cache <code>c</code> in-place.</li></ul><p><strong>Side Effects</strong></p><p>Updates <code>c</code> fields:</p><ul><li><code>ω_array</code>: Current productivity</li><li><code>ω_lom_array</code>: Lagged productivity and polynomial terms</li><li><code>ρ_hat</code>: LOM coefficients (from OLS of ω on lag_ω polynomials + shifters)</li><li><code>ξ_hat</code>: Productivity innovations (ω - predicted LOM)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.tj_prodest_criterion-Tuple{}" href="#TJProdEst.tj_prodest_criterion-Tuple{}"><code>TJProdEst.tj_prodest_criterion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tj_prodest_criterion(; data, Setup, β, weight, c)</code></pre><p>Compute the GMM (Generalized Method of Moments) criterion function value for the production function estimation. This function evaluates the weighted squared sum of moment conditions given a candidate parameter vector <code>β</code>.</p><p>The criterion is minimized during optimization to find the parameter estimates that best satisfy the moment conditions (orthogonality between instruments and residuals).</p><p><strong>Keyword arguments</strong></p><ul><li><code>data::DataFrame</code>: prepared estimation dataset with lagged variables and transformed columns.</li><li><code>Setup::Setup</code>: configuration struct containing model specification (inputs, variables, degree of ω polynomial, etc.).</li><li><code>β::Vector{&lt;:Number}</code>: candidate parameter vector ordered as  [constant, fixed<em>input</em>coeffs..., flexible<em>input</em>coeff].</li><li><code>weight::Union{Array,UniformScaling}</code>: weighting matrix for the moment conditions. Often set to identity matrix <code>I</code> for exactly identified models.</li><li><code>c::NamedTuple</code>: preallocated cache containing arrays for intermediate calculations (ϵ, ξ<em>hat, ρ</em>hat, m<em>mat, ω</em>array, etc.) to avoid repeated allocations.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: the GMM criterion value (weighted sum of squared moments), scaled by sample size.</li></ul><p><strong>Notes</strong></p><ul><li>The function computes moment conditions based on orthogonality between productivity shocks (ϵ, ξ) and observables (proxy variable, fixed inputs).</li><li>Calls <code>tj_prod_reg!</code> internally to compute residuals and ω law-of-motion parameters.</li><li>The criterion is minimized by the optimizer in <code>tj_onestep_estimator</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.tj_prodest_estimation!-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}" href="#TJProdEst.tj_prodest_estimation!-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}"><code>TJProdEst.tj_prodest_estimation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    tj_prodest_estimation!(; data, Setup, Results)</code></pre><p>Run the production estimation pipeline for the provided dataset. This high-level helper performs the core estimation steps and populates the <code>Results</code> object with point estimates and (optionally) standard error information.</p><p><strong>Keyword arguments</strong></p><ul><li><code>data::DataFrame</code>: prepared data to use for estimation (usually the   output of <code>jt_data_prep</code>).</li><li><code>Setup::Setup</code>: configuration struct describing inputs, options and   model form.</li><li><code>Results::Results</code>: mutable results container that will be filled by the   estimation routines.</li></ul><p><strong>Behavior</strong></p><ul><li>Calls the single-step estimator <code>tj_onestep_estimator</code> to compute point   estimates and writes them into <code>Results</code>.</li><li>If <code>Setup.std_err_estimation</code> is true, calls <code>tj_se_estimation!</code> to   compute standard errors (mutates <code>Results</code>).</li></ul><p><strong>Side effects</strong></p><ul><li>This function mutates the <code>Results</code> object in-place. It does not return   a new <code>Results</code> instance; it returns <code>nothing</code> implicitly.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># prepare data and setup
results, setup = tj_prod_est(data = df, output = :Y, flexible_input = [:M], fixed_inputs = [:K,:L], flexible_input_price = :Pᴹ, output_price = :Pʸ, ω_lom_degree = 1, time = :year, id = :ID)
# run lower-level estimation directly (results is mutated)
tj_prodest_estimation!(data = prepared_df, Setup = setup, Results = results)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TJProdEst.tj_std_error_stats-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}" href="#TJProdEst.tj_std_error_stats-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}"><code>TJProdEst.tj_std_error_stats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tj_std_error_stats(data, Setup, Results) -&gt; Nothing</code></pre><p>Compute standard errors, t-statistics, p-values, and confidence intervals via bootstrap resampling. Mutates the <code>Results</code> struct in-place with statistical inference results.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Estimation dataset</li><li><code>Setup::Setup</code>: Configuration including bootstrap settings (<code>boot_reps</code>, <code>std_err_type</code>)</li><li><code>Results::Results</code>: Results struct to update with inference statistics</li></ul><p><strong>Side Effects</strong></p><p>Populates the following fields in <code>Results</code>:</p><ul><li><code>variance</code>: Bootstrap variance estimates</li><li><code>std_errors</code>: Standard errors (√variance)</li><li><code>t_statistics</code>: t-statistics for hypothesis testing</li><li><code>p_values</code>: Two-sided p-values (assuming normality)</li><li><code>conf_intervals</code>: 95% confidence intervals (±1.96 × SE)</li></ul><p><strong>Notes</strong></p><ul><li>Currently only supports bootstrap standard errors</li><li>Uses <code>bootstrap_tj_prodest</code> to generate bootstrap samples</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarkusTrunschke/TJProdEst.jl">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 16 October 2025 22:45">Thursday 16 October 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

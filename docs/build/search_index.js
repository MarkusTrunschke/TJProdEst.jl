var documenterSearchIndex = {"docs":
[{"location":"#TJProdEst","page":"Home","title":"TJProdEst","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TJProdEst.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#TJProdEst.Results","page":"Home","title":"TJProdEst.Results","text":"Results\n\nMutable struct storing estimation results with nested NamedTuples for production function and ω law-of-motion parameters.\n\nFields\n\npoint_estimates::NamedTuple: Point estimates with (prd_fnc, ω_lom) structure\nstd_errors::NamedTuple: Standard errors \nvariance::NamedTuple: Variance estimates\np_values::NamedTuple: p-values for hypothesis tests\nt_statistics::NamedTuple: t-statistics\nconf_intervals::NamedTuple: Confidence intervals (2-element vectors)\ncriterion_value::Float64: Final GMM criterion value\n\n\n\n\n\n","category":"type"},{"location":"#TJProdEst.Setup","page":"Home","title":"TJProdEst.Setup","text":"Setup\n\nImmutable struct storing estimation configuration and data settings.\n\nFields\n\noutput::Symbol: Output variable column name\nflexible_input::Symbol: Flexible input variable (e.g., materials)\nfixed_inputs::Union{Symbol,Vector{Symbol}}: Fixed input(s) (e.g., capital, labor)\nflexible_input_price::Symbol: Price for flexible input\nall_inputs::Vector{Symbol}: Concatenation of fixed_inputs and flexible_input\noutput_price::Symbol: Output price variable\nω_lom_degree::Int: Polynomial degree for ω law-of-motion\nω_shifter::Union{Symbol, Vector{Symbol}}: Additional shifters in ω LOM\ntime::Union{Symbol, Missing}: Time variable for panel data\nid::Union{Symbol, Missing}: Firm/panel identifier\nprd_fnc_form::String: Production function form (e.g., \"CobbDouglas\")\nstd_err_estimation::Bool: Whether to compute standard errors\nstd_err_type::String: Standard error method (e.g., \"Bootstrap\")\nboot_reps::Int: Number of bootstrap replications\nmaximum_boot_tries::Int: Maximum retry attempts for bootstrap\noptimizer_options::NamedTuple: Optimization settings (bounds, startvals, optimizer, optim_options)\n\n\n\n\n\n","category":"type"},{"location":"#TJProdEst.bootstrap_tj_prodest-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}","page":"Home","title":"TJProdEst.bootstrap_tj_prodest","text":"bootstrap_tj_prodest(data, Setup, Results) -> Matrix{Float64}\n\nGenerate bootstrap estimates by resampling firms and re-estimating the model. Returns a matrix where each row contains parameter estimates from one bootstrap replication.\n\nArguments\n\ndata::DataFrame: Estimation dataset\nSetup::Setup: Configuration with boot_reps and maximum_boot_tries\nResults::Results: Results struct (used for parameter structure)\n\nReturns\n\nMatrix{Float64}: Bootstrap estimates matrix of size  (boot_reps × n_params) where n_params = production function params +  ω LOM params. Each row is one bootstrap replication.\n\nDetails\n\nUses panel bootstrap: samples firms with replacement, keeps entire time series\nParallelized across bootstrap repetitions using Threads.@threads\nRetries failed estimations up to maximum_boot_tries times per replication\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.draw_sample-Tuple{}","page":"Home","title":"TJProdEst.draw_sample","text":"draw_sample(; data, id, sample_size=length(unique(data[!, id])), with_replacement=true) -> DataFrame\n\nDraw bootstrap sample of firms from panel data. Assigns unique IDs to resampled firms to avoid duplicate ID issues in subsequent panel operations.\n\nKeyword Arguments\n\ndata::DataFrame: Panel dataset to sample from\nid::Symbol: Firm identifier column\nsample_size::Int: Number of firms to sample (default: all unique firms)\nwith_replacement::Bool=true: Sample with or without replacement\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.fastOLS-Tuple{}","page":"Home","title":"TJProdEst.fastOLS","text":"fastOLS(; Y, X, multicolcheck=true, force=false) -> Vector{Float64}\n\nCompute OLS coefficients β̂ = (X'X)⁻¹X'Y using in-place Cholesky decomposition for minimal allocations. Optionally checks and handles multicollinearity.\n\nKeyword Arguments\n\nY::Union{Matrix, Vector}: Dependent variable(s)\nX::Union{Matrix{<:Number}, Vector{<:Number}}: Design matrix of regressors\nmulticolcheck::Bool=true: Check for perfect multicollinearity\nforce::Bool=false: Auto-drop multicollinear columns with warning instead of error\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.jt_data_prep-Tuple{DataFrame, TJProdEst.Setup}","page":"Home","title":"TJProdEst.jt_data_prep","text":"jt_data_prep(data::DataFrame, Setup::Setup) -> DataFrame\n\nPrepare panel data for estimation by computing proxy variable (log flexible input share) and creating lagged variables. Returns filtered dataset with complete observations.\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.lagging_that_panel!-Tuple{}","page":"Home","title":"TJProdEst.lagging_that_panel!","text":"lagging_that_panel!(; data, id, time, variable, lag_prefix=\"lag_\", lags=1, drop_missings=false) -> DataFrame\n\nInternal helper for panel_lag!. Computes lags using ShiftedArrays.lag within groups, validates time gaps (sets to missing if gap ≠ lags), joins back to data, and renames columns.\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.panel_lag!-Tuple{}","page":"Home","title":"TJProdEst.panel_lag!","text":"panel_lag!(; data, id, time, variable, lag_prefix=\"lag_\", lags=1, drop_missings=false, force=false) -> DataFrame\n\nCompute panel lags in-place using ShiftedArrays.lag within groups. Sorts by id and time, creates lag columns with specified prefix, and validates time gaps.\n\nKeyword Arguments\n\ndata::DataFrame: Data frame to mutate\nid::Symbol: Panel identifier column\ntime::Symbol: Time variable for ordering\nvariable::Union{Vector{Symbol},Symbol}: Column(s) to lag\nlag_prefix::String=\"lag_\": Prefix for lag column names\nlags::Int=1: Lag distance\ndrop_missings::Bool=false: Drop rows with missing lags\nforce::Bool=false: Remove existing lag columns if present\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.polynomial_fnc_fast!-Tuple{Union{SubArray{<:Number}, Array{<:Number}}, Int64}","page":"Home","title":"TJProdEst.polynomial_fnc_fast!","text":"polynomial_fnc_fast!(poly_mat, degree; par_cal=false) -> poly_mat\n\nIn-place computation of polynomial terms. Fills columns 2 through degree of poly_mat with powers 2 through degree of column 1. Preallocated matrix avoids allocations during repeated calls.\n\nArguments\n\npoly_mat::Union{Array{<:Number}, SubArray{<:Number}}: Matrix with base values in column 1\ndegree::Int: Highest polynomial degree to compute\n\nKeyword Arguments\n\npar_cal::Bool=false: Use Threads.@threads for parallel computation\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.polynomial_fnc_fast!-Tuple{Union{SubArray{<:Number}, Array{<:Number}}, Int64}-2","page":"Home","title":"TJProdEst.polynomial_fnc_fast!","text":"polynomial_fnc_fast!(poly_mat, degree; par_cal=false) -> poly_mat\n\nIn-place computation of polynomial terms from a base variable. This function mutates poly_mat by filling its columns with successive powers of the first column: the i-th column is set to (first column)^i.\n\nThis is a performance-optimized version designed for repeated evaluations where the matrix has already been preallocated. It avoids dynamic allocations at runtime by mutating the input matrix directly (hence the trailing !).\n\nArguments\n\npoly_mat::Union{Array{<:Number}, SubArray{<:Number}}: A matrix where the first column contains the base values and columns 2 through degree will be filled with polynomial terms. Must have at least degree columns.\ndegree::Int: The highest polynomial degree to compute. For example, if degree=3, columns 2 and 3 will contain the squared and cubed values of column 1, respectively.\n\nKeyword Arguments\n\npar_cal::Bool=false: If true, uses parallel computation via Threads.@threads to compute polynomial columns concurrently.\n\nReturns\n\nReturns the mutated poly_mat with polynomial columns filled in-place.\n\nNotes\n\nThe function assumes poly_mat has been preallocated with sufficient columns (at least degree columns). No bounds checking is performed.\nColumn 1 is never modified; it serves as the base for all polynomial terms.\nColumns 2 through degree are overwritten with powers 2 through degree.\nFor small datasets or low degrees, par_cal=false (sequential) is typically faster due to threading overhead.\n\nExample\n\n# Preallocate a matrix with 3 columns for base values and polynomials up to degree 3\npoly_mat = zeros(100, 3)\npoly_mat[:, 1] .= rand(100)  # Fill first column with base values\n\n# Compute polynomial terms in-place\npolynomial_fnc_fast!(poly_mat, 3)\n# Now poly_mat[:, 2] contains squared values, poly_mat[:, 3] contains cubed values\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.res_struct_init-Tuple{TJProdEst.Setup}","page":"Home","title":"TJProdEst.res_struct_init","text":"res_struct_init(Setup::Setup) -> Results\n\nInitialize a Results struct with missing values based on Setup configuration. Creates nested NamedTuples for production function (constant + all_inputs) and ω law-of-motion (ω terms + shifters) parameters.\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.setup_struct_init-Tuple{Symbol, Symbol, Union{Symbol, Vector{Symbol}}, Symbol, Symbol, Int64, Union{Symbol, Vector{Symbol}}, Union{Missing, Symbol}, Union{Missing, Symbol}, String, Bool, String, Int64, Int64, NamedTuple}","page":"Home","title":"TJProdEst.setup_struct_init","text":"setup_struct_init(data, output, flexible_input, fixed_inputs, flexible_input_price,\n                  output_price, ω_lom_degree, time, id, prd_fnc_form, options) -> Setup\n\nConstruct a Setup struct with all estimation configuration. Merges user-provided optimizer_options      with defaults and builds all_inputs by concatenating fixed_inputs and flexible_input.\n\nArguments\n\ndata::DataFrame: the input dataset.\noutput::Symbol: dependent variable (output) column name.\nflexible_input::Vector{Symbol}: vector of flexible input column names.\nfixed_inputs::Vector{Symbol}: vector of fixed input column names.\nflexible_input_price::Symbol: price variable for the flexible input.\noutput_price::Symbol: price variable for the output.\nω_lom_degree::Int: degree for the ω polynomial (order of LOM terms).\ntime::Union{Symbol, Missing}: time variable column (or missing).\nid::Union{Symbol, Missing}: firm identifier column (or missing).\nprd_fnc_form::String: production function form (e.g. \"CobbDouglas\").\noptions::Dict{Symbol,Any}: extra options passed to the estimator.\n\nReturns\n\nSetup: a filled Setup struct ready to be used by the estimation routine.\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.superscript_this!-Tuple{String}","page":"Home","title":"TJProdEst.superscript_this!","text":"superscript_this!(c::String) -> Char\n\nConvert first character of string to its Unicode superscript equivalent using superscript_map. Returns original character if no superscript exists.\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.tj_onestep_estimator-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}","page":"Home","title":"TJProdEst.tj_onestep_estimator","text":"tj_onestep_estimator(data, Setup, Results) -> NamedTuple\n\nPerform one-step GMM estimation of production function parameters.\n\nArguments\n\ndata::DataFrame: Prepared estimation dataset containing output, inputs, prices, and lagged variables. Should be the output of jt_data_prep.\nSetup::Setup: Configuration struct containing model specification (variable names, polynomial degree, optimizer settings, etc.).\nResults::Results: Results struct that will store the criterion value and is used to determine the structure of output estimates.\n\nReturns\n\nNamedTuple: A nested NamedTuple with two fields:\nprd_fnc: Production function parameters as a NamedTuple with keys like :constant, :K, :L, :M (depends on Setup.all_inputs)\nω_lom: Productivity law-of-motion parameters as a NamedTuple with keys like :ω, :ω², etc. (depends on Setup.ω_lom_degree and Setup.ω_shifter)\n\nOptimization Details\n\nThe optimization uses Optim.jl's numerical optimization routines and allows to set all optimizer options with Optim.Options(...). One can set Box constraints providing the lower_bound and upper_bound arguments in TJProdEst.tj_prod_est combined with a Optim.Fminbox optimizer.\n\nThrows\n\nThrows an error with message \"Estimation did not converge...\" if the optimizer fails to converge.\nThrows an error for unsupported production function forms (currently only \"CobbDouglas\" is supported).\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.tj_print_res_bigestimator-Tuple{DataFrame, TJProdEst.Results, TJProdEst.Setup}","page":"Home","title":"TJProdEst.tj_print_res_bigestimator","text":"tj_print_res_bigestimator(data::DataFrame, Results::Results, Setup::Setup)\n\nPrint formatted estimation results table using PrettyTables. Displays production function and ω law-of-motion parameters with standard errors, t-statistics, p-values, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.tj_prod_est-Tuple{}","page":"Home","title":"TJProdEst.tj_prod_est","text":"tj_prod_est(; data, output, flexible_input, fixed_inputs, flexible_input_price, output_price, ω_lom_degree=1, ω_shifter=[], time, id, std_err_estimation=true, std_err_type=\"Bootstrap\", boot_reps=200, maximum_boot_tries=10, optimizer_options=NamedTuple())\n\nTop-level estimation entry point for production function estimation using the approach described in Trunschke and Judd (2024). Returns a tuple (Results, Setup) with parameter estimates and configuration.\n\nKeyword Arguments\n\ndata::DataFrame: Input dataset with (firm-time) panel structure\noutput::Symbol: Output variable column name\nflexible_input::Symbol: Flexible input variable (e.g., materials)\nfixed_inputs::Union{Symbol,Vector{Symbol}}: Fixed input variable(s) (e.g., capital, labor)\nflexible_input_price::Symbol: Price of flexible input\noutput_price::Symbol: Output price\nω_lom_degree::Int=1: Polynomial degree for productivity law-of-motion\nω_shifter::Union{Symbol,Vector{Symbol}}=[]: Optional productivity shifter variables\ntime::Symbol: Time period identifier\nid::Symbol: Firm/unit identifier\nstd_err_estimation::Bool=true: Whether to compute standard errors\nstd_err_type::String=\"Bootstrap\": Type of standard errors (\"Bootstrap\" only currently)\nboot_reps::Int=200: Number of bootstrap replications\nmaximum_boot_tries::Int=10: Max retry attempts per failed bootstrap iteration\noptimizer_options::NamedTuple=NamedTuple(): Optimization settings (see Optim.jl)\n\nReturns\n\nNamedTuple: (Results, Setup) containing estimates and configuration\n\nExample\n\nresults = tj_prod_est(\n    data = df,\n    output = :Y,\n    flexible_input = :M,\n    fixed_inputs = [:K, :L],\n    flexible_input_price = :Pᴹ,\n    output_price = :Pʸ,\n    time = :year,\n    id = :firm_id,\n)\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.tj_prod_reg!","page":"Home","title":"TJProdEst.tj_prod_reg!","text":"tj_prod_reg!(data, Setup, β, c) -> Nothing\n\nIn-place computation of productivity (ω) terms and the law-of-motion (LOM)  regression for the production function estimation. This function implements  the core calculations for the proxy variable approach, computing current and  lagged productivity, estimating the productivity LOM via OLS, and calculating  the structural error (ξ).\n\nThis is a mutating function (hence the !) that updates the preallocated  arrays in the c cache NamedTuple in-place for efficiency.\n\nArguments\n\ndata::DataFrame: The estimation dataset containing output, inputs, prices,  and lagged variables. Must include columns for current and lagged values of  all production function variables.\nSetup::Setup: The setup struct containing configuration parameters including  variable names, polynomial degree, and production function form.\nβ::Union{Vector{<:Number}, SubArray{...}}: Production function parameters  vector. The ordering is: [constant, fixedinputcoeffs..., flexibleinputcoeff]. For Cobb-Douglas: β = [α₀, αₖ₁, αₖ₂, ..., αₘ] where K's are fixed inputs and  M is the flexible input.\nc::NamedTuple: Cache NamedTuple containing preallocated arrays for intermediate  calculations. Must include fields: ω_array, ω_lom_array, ρ_hat, ξ_hat.  These arrays are mutated in-place.\n\nReturns\n\nNothing (the function mutates c in-place)\n\nSide Effects (Mutations)\n\nThe function updates the following fields in c:\n\nc.ω_array: Filled with current productivity (ω) computed from the production  function residual after accounting for inputs and the proxy variable.\nc.ω_lom_array: First column filled with lagged productivity (lagω), then  polynomial terms computed via `polynomialfnc_fast!`, and ω-shifter columns  (if present) that were preallocated during setup.\nc.ρ_hat: Filled with OLS coefficients from regressing ω on its lagged  polynomial terms and ω-shifters (the LOM parameters).\nc.ξ_hat: Filled with structural error (innovation to productivity), computed  as ξ = ω - LOM(lagω, ωshifters).\n\nImplementation Details\n\nThe productivity term ω is recovered from the production function by solving:\n\nω = ln(Y) + ln(Pᴹ·M / Pʸ·Y) - ln(M) - β₀ - βₘ - ∑βₖ·ln(K) - (βₘ - 1)·ln(M)\n\nwhere the proxy variable relationship is used to invert for productivity.\n\nThe law-of-motion is estimated via OLS:\n\nω = ρ₀ + ρ₁·lag_ω + ρ₂·lag_ω² + ... + ρₚ·lag_ωᵖ + ρ_shifters·shifters + ξ\n\nExample\n\n# Called internally during GMM criterion evaluation\ntj_prod_reg!(est_data, Setup, β_current, cache)\n# cache.ξ_hat now contains the structural errors\n# cache.ρ_hat contains the LOM parameters\n\nSee Also\n\ntj_prodest_criterion: Uses this function to compute moment conditions\npolynomial_fnc_fast!: Computes polynomial terms for the LOM\nfastOLS: Estimates the LOM coefficients\n\n\n\n\n\n","category":"function"},{"location":"#TJProdEst.tj_prod_reg!-2","page":"Home","title":"TJProdEst.tj_prod_reg!","text":"tj_prod_reg!(data, Setup, β, c) -> Nothing\n\nCompute productivity (ω) and its law-of-motion via in-place OLS regression. Mutates the cache c with productivity terms, LOM parameters, and structural errors.\n\nArguments\n\ndata::DataFrame: Estimation dataset with output, inputs, and lagged variables\nSetup::Setup: Configuration (variable names, polynomial degree)\nβ::Vector{<:Number}: Production function parameters [constant, fixedinputs..., flexibleinput]\nc::NamedTuple: Preallocated cache to mutate\n\nReturns\n\nNothing: The function mutates the cache c in-place.\n\nSide Effects\n\nUpdates c fields:\n\nω_array: Current productivity\nω_lom_array: Lagged productivity and polynomial terms\nρ_hat: LOM coefficients (from OLS of ω on lag_ω polynomials + shifters)\nξ_hat: Productivity innovations (ω - predicted LOM)\n\n\n\n\n\n","category":"function"},{"location":"#TJProdEst.tj_prodest_criterion-Tuple{}","page":"Home","title":"TJProdEst.tj_prodest_criterion","text":"tj_prodest_criterion(; data, Setup, β, weight, c)\n\nCompute the GMM (Generalized Method of Moments) criterion function value for the production function estimation. This function evaluates the weighted squared sum of moment conditions given a candidate parameter vector β.\n\nThe criterion is minimized during optimization to find the parameter estimates that best satisfy the moment conditions (orthogonality between instruments and residuals).\n\nKeyword arguments\n\ndata::DataFrame: prepared estimation dataset with lagged variables and transformed columns.\nSetup::Setup: configuration struct containing model specification (inputs, variables, degree of ω polynomial, etc.).\nβ::Vector{<:Number}: candidate parameter vector ordered as  [constant, fixedinputcoeffs..., flexibleinputcoeff].\nweight::Union{Array,UniformScaling}: weighting matrix for the moment conditions. Often set to identity matrix I for exactly identified models.\nc::NamedTuple: preallocated cache containing arrays for intermediate calculations (ϵ, ξhat, ρhat, mmat, ωarray, etc.) to avoid repeated allocations.\n\nReturns\n\nFloat64: the GMM criterion value (weighted sum of squared moments), scaled by sample size.\n\nNotes\n\nThe function computes moment conditions based on orthogonality between productivity shocks (ϵ, ξ) and observables (proxy variable, fixed inputs).\nCalls tj_prod_reg! internally to compute residuals and ω law-of-motion parameters.\nThe criterion is minimized by the optimizer in tj_onestep_estimator.\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.tj_prodest_estimation!-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}","page":"Home","title":"TJProdEst.tj_prodest_estimation!","text":"    tj_prodest_estimation!(; data, Setup, Results)\n\nRun the production estimation pipeline for the provided dataset. This high-level helper performs the core estimation steps and populates the Results object with point estimates and (optionally) standard error information.\n\nKeyword arguments\n\ndata::DataFrame: prepared data to use for estimation (usually the   output of jt_data_prep).\nSetup::Setup: configuration struct describing inputs, options and   model form.\nResults::Results: mutable results container that will be filled by the   estimation routines.\n\nBehavior\n\nCalls the single-step estimator tj_onestep_estimator to compute point   estimates and writes them into Results.\nIf Setup.std_err_estimation is true, calls tj_se_estimation! to   compute standard errors (mutates Results).\n\nSide effects\n\nThis function mutates the Results object in-place. It does not return   a new Results instance; it returns nothing implicitly.\n\nExample\n\n# prepare data and setup\nresults, setup = tj_prod_est(data = df, output = :Y, flexible_input = [:M], fixed_inputs = [:K,:L], flexible_input_price = :Pᴹ, output_price = :Pʸ, ω_lom_degree = 1, time = :year, id = :ID)\n# run lower-level estimation directly (results is mutated)\ntj_prodest_estimation!(data = prepared_df, Setup = setup, Results = results)\n\n\n\n\n\n","category":"method"},{"location":"#TJProdEst.tj_std_error_stats-Tuple{DataFrame, TJProdEst.Setup, TJProdEst.Results}","page":"Home","title":"TJProdEst.tj_std_error_stats","text":"tj_std_error_stats(data, Setup, Results) -> Nothing\n\nCompute standard errors, t-statistics, p-values, and confidence intervals via bootstrap resampling. Mutates the Results struct in-place with statistical inference results.\n\nArguments\n\ndata::DataFrame: Estimation dataset\nSetup::Setup: Configuration including bootstrap settings (boot_reps, std_err_type)\nResults::Results: Results struct to update with inference statistics\n\nSide Effects\n\nPopulates the following fields in Results:\n\nvariance: Bootstrap variance estimates\nstd_errors: Standard errors (√variance)\nt_statistics: t-statistics for hypothesis testing\np_values: Two-sided p-values (assuming normality)\nconf_intervals: 95% confidence intervals (±1.96 × SE)\n\nNotes\n\nCurrently only supports bootstrap standard errors\nUses bootstrap_tj_prodest to generate bootstrap samples\n\n\n\n\n\n","category":"method"}]
}
